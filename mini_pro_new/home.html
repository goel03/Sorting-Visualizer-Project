<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>minipro</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"
    integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css"
        integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="style.css">
    <script src="javascript.js"></script>
    
</head>

<body>

    <div class="topbar"></div>
    <div class="navbar">
        <h1>VISUALIZER</h1>
        <div class="icon">
            <a href="#"><i class="fa-solid fa-bars"></i></a>
        </div>
        <nav class="nav-section">
            <a href="#" class="off"><i class="fa-solid fa-xmark"></i></a>
            <ul>
                <li><a href="#para">ABOUT</a></li>
                <li><a href="#info">TYPES</a></li>
                
            </ul>
        </nav>
    </div>

    <div class="container">
        <h1><span>Sorting Visualizer</span> </h1>

    </div>
    <div class="para"id="para">
        <h1> What Is Sorting ?</h1>

        <br>
        <p>The arrangement of data in a preferred order is called sorting in the data structure. By sorting data, it is
            easier to search through it quickly and easily. The simplest example of sorting is a dictionary. Before the
            era of the Internet, when you wanted to look up a word in a dictionary, you would do so in alphabetical
            order. This made it easy.

            Imagine the panic if you had to go through a big book with all the English words from the world in a jumbled
            order! It is the same panic an engineer will go through if their data is not sorted and structured.

        </p>
        <br>
        <p>A sorting algorithm is just a series of orders or instructions. In this, an array is an input, on which the
            sorting algorithm performs operations to give out a sorted array.

            Many children would have learned to sort in data structures in their computer science classes. It is
            introduced at an early stage to help interested children get an idea of deeper computer science topics –
            divide-and-conquer methods, binary trees, heaps, etc.

            Here’s an example of what sorting does.

            Let’s suppose you have an array of strings: [h,j,k,i,n,m,o,l]

            Now, sorting would yield an output array in alphabetical order.

            Output: [h,i,j,k,l,m,n,o]</p>
    </div>


    <include src="sort/index.html"></include>
   
    <section class="vis">
       

        <div class="vis-row">
            <div class="vis-col">
            <a href="sort/index.html" style="text-decoration :none"><h1> Click here to Visualise the Algorithms </h1></a>
            </div>
           

        </div>
        
    </section>


    <section class="info" id="info">
       
        <h1> Want To Know More About Algorithms</h1>
        <div class="box">
            <div class="left">

                <ul class="algo">
                    <li class="algos" id="1">Bubble Sort</li>
                    <li class="algos" id="2">Selection Sort </li>
                    <li class="algos" id="3">Insertion Sort</li>
                    <li class="algos" id="4">Quick Sort</li>
                    <li class="algos" id="5">Merge Sort</li>
                    
                </ul>

            </div>



            <div class="right">
                <section class="data1">
                    <div class="d1">
                        <h2>BUBBLE SORT</h2>
                        <br>
                        <p> Bubble sort works on the repeatedly swapping of adjacent elements until they are not in the
                            intended order.
                            It is called bubble sort because the movement of array elements is just like the movement of
                            air bubbles in
                            the water. Bubbles in water rise up to the surface; similarly, the array elements in bubble
                            sort move to the
                            end in each iteration.</p>

                        <p>Although it is simple to use, it is primarily used as an educational tool because the
                            performance of bubble
                            sort is poor in the real world. It is not suitable for large data sets. The average and
                            worst-case
                            complexity of Bubble sort is O(n2), where n is a number of items.</p>

                        Bubble short is majorly used where -
                        <br>
                        Complexity does not matter<br>
                        Simple and shortcode is preferred<br>
                        <br>
                        <h3>Bubble sort complexity</h3>
                        Now, let's see the time complexity of bubble sort in the best case, average case, and worst
                        case.<br> We will
                        also see the space complexity of bubble sort.
                        <br><br>
                        <pre>
1. Time Complexity
  Case	       Time Complexity
Best Case	        O(n)
Average Case	        O(n2)
Worst Case	        O(n2)
</pre><br><br>
                        <b>Best Case Complexity </b>- It occurs when there is no sorting required, i.e. the array is
                        already sorted.
                        The best-case time complexity of bubble sort is O(n).<br>
                        <b>Average Case Complexity </b>- It occurs when the array elements are in jumbled order that is
                        not properly
                        ascending and not properly descending. The average case time complexity of bubble sort is
                        O(n2).<br>
                        <b>Worst Case Complexity </b>- It occurs when the array elements are required to be sorted in
                        reverse order.
                        That means suppose you have to sort the array elements in ascending order, but its elements are
                        in descending
                        order. The worst-case time complexity of bubble sort is O(n2).
                        <br><br><br>
                        <pre>
2. Space Complexity
Space Complexity    O(1)
Stable	            YES
</pre><br><br>
                        The space complexity of bubble sort is O(1). It is because, in bubble sort, an extra variable is
                        required for
                        swapping.<br>
                        The space complexity of optimized bubble sort is O(2). It is because two extra variables are
                        required in
                        optimized bubble sort.<br>
                        <br><br>

                        <h3>Optimized Bubble sort Algorithm</h3>
                        In the bubble sort algorithm, comparisons are made even when the array is already sorted.
                        Because of that, the
                        execution time increases.

                        To solve it, we can use an extra variable swapped. It is set to true if swapping requires;
                        otherwise, it is set
                        to false.

                        It will be helpful, as suppose after an iteration, if there is no swapping required, the value
                        of variable
                        swapped will be false. It means that the elements are already sorted, and no further iterations
                        are
                        required.<br>


                        This method will reduce the execution time and also optimizes the bubble sort.
                    </div>
                </section>
                <div class="d2">
                    <section class="data2">

                        <h2>SELECTION SORT</h2>
                        <br>
                        <p>
                            In selection sort, the smallest value among the unsorted elements of the array is selected
                            in
                            every pass and
                            inserted to its appropriate position into the array. It is also the simplest algorithm. It
                            is an
                            in-place
                            comparison sorting algorithm. In this algorithm, the array is divided into two parts, first
                            is
                            sorted part,
                            and another one is the unsorted part. Initially, the sorted part of the array is empty, and
                            unsorted part is
                            the given array. Sorted part is placed at the left, while the unsorted part is placed at the
                            right.</p>

                        <p> In selection sort, the first smallest element is selected from the unsorted array and placed
                            at
                            the first
                            position. After that second smallest element is selected and placed in the second position.
                            The
                            process
                            continues until the array is entirely sorted.

                            The average and worst-case complexity of selection sort is O(n2), where n is the number of
                            items. Due to
                            this,
                            it is not suitable for large data sets.</p><br>



                        Selection sort is generally used when -<br>

                        A small array is to be sorted<br>
                        Swapping cost doesn't matter<br>
                        It is compulsory to check all elements<br>
                        <br>
                        <h3>Selection sort complexity</h3>
                        Now, let's see the time complexity of selection sort in best case, average case, and in worst
                        case.
                        We will also
                        see the space complexity of the selection sort.
                        <br><br>
                        <pre>

1. Time Complexity
Case	Time Complexity
Best Case     O(n2)
Average Case  O(n2)
Worst Case    O(n2)</pre><br><br>
                        <b>Best Case Complexity</b> - It occurs when there is no sorting required, i.e. the array is
                        already
                        sorted. The
                        best-case time complexity of selection sort is O(n2).<br>
                        <b>Average Case Complexity </b>- It occurs when the array elements are in jumbled order that is
                        not
                        properly
                        ascending and not properly descending. The average case time complexity of selection sort is
                        O(n2).<br>
                        <b>Worst Case Complexity </b>- It occurs when the array elements are required to be sorted in
                        reverse order.
                        That means suppose you have to sort the array elements in ascending order, but its elements are
                        in
                        descending
                        order. The worst-case time complexity of selection sort is O(n2).
                        <br><br>
                        <pre>
2. Space Complexity
Space Complexity   O(1)
Stable             YES</pre><br><br>
                        The space complexity of selection sort is O(1). It is because, in selection sort, an extra
                        variable
                        is required
                        for swapping.
                    </section>
                </div>
                <div class="d3">
                    <section class="data3">
                        <h2>INSERTION SORT</h2>
                        <br>
                        <p>
                            Insertion sort works similar to the sorting of playing cards in hands. It is assumed that
                            the
                            first card is
                            already sorted in the card game, and then we select an unsorted card. If the selected
                            unsorted
                            card is
                            greater than the first card, it will be placed at the right side; otherwise, it will be
                            placed
                            at the left
                            side. Similarly, all unsorted cards are taken and put in their exact place.</p>

                        <p> The same approach is applied in insertion sort. The idea behind the insertion sort is that
                            first
                            take one
                            element, iterate it through the sorted array. Although it is simple to use, it is not
                            appropriate for large
                            data sets as the time complexity of insertion sort in the average case and worst case is
                            O(n2),
                            where n is
                            the number of items. Insertion sort is less efficient than the other sorting algorithms like
                            heap sort,
                            quick sort, merge sort, etc.</p><br>



                        Insertion sort has various advantages such as -<br>

                        Simple implementation<br>
                        Efficient for small data sets<br>
                        Adaptive, i.e., it is appropriate for data sets that are already substantially sorted<br>

                        <br>
                        <h3>Insertion sort complexity</h3>
                        Now, let's see the time complexity of insertion sort in best case, average case, and in worst
                        case.
                        We will also
                        see the space complexity of insertion sort.
                        <br><br>
                        <pre>

1. Time Complexity
Case	Time Complexity
Best Case     O(n)
Average Case  O(n^2)
Worst Case    O(n^2)</pre><br><br>
                        <b>Best Case Complexity</b> - It occurs when there is no sorting required, i.e. the array is
                        already
                        sorted. The
                        best-case time complexity of insertion sort is O(n).<br>
                        <b>Average Case Complexity </b>- It occurs when the array elements are in jumbled order that is
                        not
                        properly
                        ascending and not properly descending. The average case time complexity of insertion sort is
                        O(n2)<br>
                        <b>Worst Case Complexity</b> - It occurs when the array elements are required to be sorted in
                        reverse order.
                        That means suppose you have to sort the array elements in ascending order, but its elements are
                        in
                        descending
                        order. The worst-case time complexity of insertion sort is O(n2).
                        <br><br>
                        <pre>
2. Space Complexity
Space Complexity   O(1)
Stable             YES</pre><br><br>
                        The space complexity of insertion sort is O(1). It is because, in insertion sort, an extra
                        variable
                        is required
                        for swapping.
                    </section>
                </div>
                <div class="d4">
                    <section class="data4">
                        <h2>QUICK SORT</h2>
                        <br>
                        <p>
                            Sorting is a way of arranging items in a systematic manner. Quicksort is the widely used
                            sorting
                            algorithm
                            that makes n log n comparisons in average case for sorting an array of n elements. It is a
                            faster and highly
                            efficient sorting algorithm. This algorithm follows the divide and conquer approach. Divide
                            and
                            conquer is a
                            technique of breaking down the algorithms into subproblems, then solving the subproblems,
                            and
                            combining the
                            results back together to solve the original problem.</p>

                        <p><b>Divide: </b>In Divide, first pick a pivot element. After that, partition or rearrange the
                            array into two
                            sub-arrays such that each element in the left sub-array is less than or equal to the pivot
                            element and each
                            element in the right sub-array is larger than the pivot element.

                            <br><b> Conquer:</b> Recursively, sort two subarrays with Quicksort.
                        </p>
                        <br><b> Combine:</b> Combine the already sorted array.</p><br>

                        <p>Quicksort picks an element as pivot, and then it partitions the given array around the picked
                            pivot element.
                            In quick sort, a large array is divided into two arrays in which one holds values that are
                            smaller than the
                            specified value (Pivot), and another array holds the values that are greater than the pivot.
                        </p>

                        After that, left and right sub-arrays are also partitioned using the same approach. It will
                        continue
                        until the
                        single element remains in the sub-array.<br>


                        <br>
                        <h3>Choosing the pivot</h3>
                        <p>
                            Picking a good pivot is necessary for the fast implementation of quicksort. However, it is
                            typical to
                            determine a good pivot. Some of the ways of choosing a pivot are as follows -
                        </p>
                        Pivot can be random, i.e. select the random pivot from the given array.<br>
                        Pivot can either be the rightmost element of the leftmost element of the given array.<br>
                        Select median as the pivot element.<br>


                        <br>
                        <h3>Quicksort complexity</h3>
                        Now, let's see the time complexity of quick sort in best case, average case, and in worst case.
                        We
                        will also
                        see the space complexity of quick sort.
                        <br><br>
                        <pre>

1. Time Complexity
Case	Time Complexity
Best Case     O(n*log(n))
Average Case  O(n*log(n))
Worst Case    O(n^2)</pre><br><br>
                        <b>Best Case Complexity</b> - In Quicksort, the best-case occurs when the pivot element is the
                        middle element or
                        near to the middle element. The best-case time complexity of quicksort is O(n*logn)<br>
                        <b>Average Case Complexity </b>-It occurs when the array elements are in jumbled order that is
                        not
                        properly
                        ascending and not properly descending. The average case time complexity of quicksort is
                        O(n*logn)<br>
                        <b>Worst Case Complexity</b> - In quick sort, worst case occurs when the pivot element is either
                        greatest or
                        smallest element. Suppose, if the pivot element is always the last element of the array, the
                        worst
                        case would
                        occur when the given array is sorted already in ascending or descending order. The worst-case
                        time
                        complexity of
                        quicksort is O(n2).
                        <br><br>
                        <p>Though the worst-case complexity of quicksort is more than other sorting algorithms such as
                            Merge
                            sort and
                            Heap sort, still it is faster in practice. Worst case in quick sort rarely occurs because by
                            changing the
                            choice of pivot, it can be implemented in different ways. Worst case in quicksort can be
                            avoided
                            by choosing
                            the right pivot element</p><br><br>
                        <pre>

2. Space Complexity
Space Complexity   O(n*logn)
Stable             NO</pre><br><br>
                        The space complexity of quicksort is O(n*logn).
                    </section>
                </div>
                <div class="d5">
                    <section class="data5">
                        <h2>MERGE SORT</h2>
                        <br>
                        <p>
                            Merge sort is similar to the quick sort algorithm as it uses the divide and conquer approach
                            to
                            sort the
                            elements. It is one of the most popular and efficient sorting algorithm. It divides the
                            given
                            list into two
                            equal halves, calls itself for the two halves and then merges the two sorted halves. We have
                            to
                            define the
                            merge() function to perform the merging.</p>

                        <p> The sub-lists are divided again and again into halves until the list cannot be divided
                            further.
                            Then we
                            combine the pair of one element lists into two-element lists, sorting them in the process.
                            The
                            sorted
                            two-element pairs is merged into the four-element lists, and so on until we get the sorted
                            list.
                        </p><br>


                        <br>
                        <h3>Merge sort complexity</h3>
                        Now, let's see the time complexity of merge sort in best case, average case, and in worst case.
                        We
                        will also
                        see the space complexity of merge sort.
                        <br><br>
                        <pre>

1. Time Complexity
Case	Time Complexity
Best Case     O(n*logn)
Average Case  O(n*logn)
Worst Case    O(n*logn)</pre><br><br>
                        <b>Best Case Complexity</b> - It occurs when there is no sorting required, i.e. the array is
                        already
                        sorted. The
                        best-case time complexity of merge sort is O(n*logn).<br>
                        <b>Average Case Complexity </b>- It occurs when the array elements are in jumbled order that is
                        not
                        properly
                        ascending and not properly descending. The average case time complexity of merge sort is
                        O(n*logn)<br>
                        <b>Worst Case Complexity</b> - It occurs when the array elements are required to be sorted in
                        reverse order.
                        That means suppose you have to sort the array elements in ascending order, but its elements are
                        in
                        descending
                        order. The worst-case time complexity of merge sort is O(n*logn).
                        <br><br>
                        <pre>
2. Space Complexity
Space Complexity   O(n)
Stable             YES</pre><br><br>
                        The space complexity of merge sort is O(n). It is because, in merge sort, an extra variable is
                        required for
                        swapping.
                    </section>
                </div>
            </div> 

        </div></section>
        <button class="open-button" onclick="openForm()">FEEDBACK</button>
    
    <div class="form-popup" id="myForm">
      <form action="/send_email"   method="post" class="form-container">
        <h1>Send your views!!!</h1>
    
        <!-- <label for="email"><b>Email</b></label> -->
        <!-- <input type="email" placeholder="Enter Email" name="from"  id="from" required><br> -->
    
        <!-- <label for="psw"><b>Password</b></label>
        <input type="password" placeholder="Enter Password" name="psw" required> -->
    
        <!-- To: <input type="email" name="to" id="to"><br><br> -->


        <!-- Subject: <input type="text" name="subject" id="subject"><br><br> -->
        Message:<br> <textarea id="message" name="message"></textarea> <br><br>
        <button type="submit" value ="Send" class="btn">SEND</button>
        <button type="button" class="btn cancel" onclick="closeForm()">Close</button>
      </form>
    </div>
            <footer>
                <i class="fa-brands fa-facebook-messenger"></i>
                <i class="fa-brands fa-instagram"></i>
                <i class="fa-brands fa-twitter"></i>
            </footer>







        <script>


            $('.icon').on(
                'click', function () {
                    $('.nav-section').show()
                    $('.icon').hide()
                }
            )
            $('.off').on(
                'click', function () {
                    $('.nav-section').hide()
                    $('.icon').show()
                }
            )
            $(document).ready(function () {
                $(window).resize(function () {
                    if ($(window).width() > 800) {
                        $('.nav-section').show()
                    }
                    if ($(window).width() < 800) {
                        $('.nav-section').hide()
                        $('.icon').show()
                    }

                })
            })
            
        </script>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
    crossorigin="anonymous"></script>
    <script src="sort/js_files/bubble.js"></script>
    <script src="sort/js_files/insertion.js"></script>
    <script src="sort/js_files/merge.js"></script>
    <script src="sort/js_files/quick.js"></script>
    <script src="sort/js_files/selection.js"></script>
    <script src="sort/js_files/sorting.js"></script>

</body>

</html>